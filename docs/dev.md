## Pulling it all together - Development flow

Just having a ready source code (or bytecode) doesn't give you much - you also need to deploy it somewhere. You can think of deployment as similar to releasing a version of your traditional application, except that all blockchain deployments are permanent and immutable.

However, being permanent and immutable only refers to the blockchain in question. Nothing stops you from starting a new blockchain. And this is exactly what local development tools, including unit testing, do: they make it easy and fast to reset the blockchain state, essentially starting a new blockchain.

So when developing contracts on your local machine, you can (and should) utilize local blockchains which are easy to reset. Development tooling mostly handles this automatically in the background, but if needed you can also run a local blockchain explicitly.

Once you are ready to deploy your code to some real blockchain, which can't be reset, you should start by deploying to some test network blockchain. Each EVM blockchain, such as Ethereum, has one or more testnets which are meant for testing. You can get testnet Ethers for free, which you can then use for deployments and transactions. Testnets are good especially for collaborative testing: doing manual tests which require multiple parties, since multiple parties can't utilize your local blockchain.

After testnet, the next logical step is deploying to mainnet.

## Example project files and folder structure

Let's use this project to explain what different folders are used for and what the files are. Let's go through the folders and files alphabetically:
- Folder *.vscode*: contains settings used in Visual Studio Code. For example extension recommendations. This is created by the developer.
- Folder *artifacts*: contains compiled Solidity bytecodes for all the used contracts. This is generated by Hardhat.
- Folder *assets*: contains images used in documentation. This is created by the developer.
- Folder *cache*: internal cache used by Hardhat. This is generated by Hardhat.
- Folder *contracts*: contains source code for all the used contracts. This is the default folder name used by Hardhat, but can be configured. this is created by the developer.
- Folder *docs*: documentation for the project and tutorial. This is created by the developer.
- Folder *node_modules*: contains all the used packages as listed in file *package.json*. This is generated by the package manager, NPM.
- Folder *scripts*: contains various scripts. Currently contains only the deployment script. This is created by the developer.
- Folder *test*: contains all the unit tests. This is the default folder name used by Hardhat (for its unit test tooling), but can be configured. This is created by the developer.
- Folder *typechain-types*: contains TypeScript definitions for all the used contracts. These can be used by your TypeScript code (unit tests and scripts mostly). This is generated by Hardhat.
- File *.env*: contains all the secret information required by the project, such as the deployer's private key. This is created by the developer.
- File *.env.example*: contains a template for to be used as the *.env* file. This is created by the developer.
- File *.gitignore*: contains list of files/folders which are not added to version control. This is created by the developer.
- File *hardhat.config.ts*: contains settings for Hardhat. This is created by the developer.
- File *package-lock.json*: contains information about used packages. This is generated by the package manager, NPM.
- File *package.json*: contains information about the project and the packages it requires. This is created by the developer.
- File *README.md*: contains main documentation and links to sub-documents. This is created by the developer.
- File *tsconfig.json*: contains configuration for TypeScript. This is created by the developer.

## Example contract functionality

The contract presented in this repository (file *contracts/Voting.sol*) is a simple voting contract to distribute native assets sent to the contract. This is only created for learning purposes and is not meant to be used in real use.

The contract supports the following functionalities:
- A static list of voter addresses is provided to the contract upon deployment
- Voters can suggest a charity donation address
- At some point the voters vote whether the gathered assets should be sent to the target charity or not
- If enough voters agree, the assets can be distributed to the charity
- Anyone can send the blockchain's native asset to the contract to donate to the target charity

What is missing from this project:
- Resetting the vote state after the charity donation has been distributed
- Various supporting functionality, such a changing vote, withdrawing vote, abstain votes, ...

## Unit tests

Unit tests are small pieces of code which make sure certain specific functionality works in the smart contract. They help in making sure the contract works as intended, but also to help retain the desired functionality when changes are made to the contract.

The project contains decent unit tests. The tests are written with Chai/Mocha JS test frameworks, with some Solidity-specific extensions.

## Used libraries and technologies

This project uses the following components:
- [Solidity](https://soliditylang.org/) language
- JavaScript, TypeScript
- [Hardhat](https://hardhat.org/) development environment
- Hardhat toolbox plugin, which includes the following notable packages:
  - [ethers.js](https://docs.ethers.org/v5/) Ethereum blockchain interaction library
  - [Mocha](https://mochajs.org/) and [Chai](https://chaijs.com/) JavaScript testing libraries
  - [Typechain](https://github.com/dethcrypto/TypeChain/) for creating TypeScript bindings for Solidity contracts

## Installation

1. Get the project's files from [GitHub](https://github.com/GoodCartel/SolidityTraining). Download as ZIP if you're not sure how to clone the repository itself
1. If not installed, [install node](https://nodejs.org/en/download)
1. Open a terminal in the project's root folder
1. Run `npm install`
1. To run unit tests, run `npx hardhat test`
1. For deployment, see below for details

## Deploying the example contract

To deploy the example contract to the Sepolia testnet, you should:

1. Have an account (a wallet) with enough Ether for deployment
  1. To create an account, you can use a browser wallet extension. [Metamask](https://metamask.io/) is one popular wallet extension. Once you have it installed, you can switch network to Sepolia and create a new account.
  1. To get free Ether in the Sepolia testnet, you need a faucet. You can for example run this faucet for a while: https://sepolia-faucet.pk910.de/ . It takes a while to 'generate' Ether in order to deter spam attacks. You won't need more than 0.1 Eth. Do note that this is not a real Proof of Work protocol.
1. Create a new file called `.env` in the project root folder. You can just duplicate the file `.env.example` to have a ready template. The `.env` file is a store for secret information. All information is represented as key-value pairs. See the attached image for an example on how it looks.
1. Export the created account's private key. Metamask offers this possibility through the account settings, instructions [here](https://support.metamask.io/hc/en-us/articles/360015289632-How-to-export-an-account-s-private-key). Add this private key to the `.env` file with the key `SEPOLIA_PRIVATE_KEY`. This private key is used to sign deployment transactions - so this account will be the one deploying contracts (and paying for the deployment).
1. Go to https://etherscan.io and create an Etherscan account there. Create an API key, export it and add it to `.env` with key `ETHERSCAN_API_KEY`. This is used to verify contracts in the Etherscan blockchain explorer.
1. Go to https://alchemy.com and create an Alchemy account. Create a new app in the Sepolia network. Export its full HTTPS url and add it to `.env` with key `SEPOLIA_PROVIDER_URL`. This is the blockchain connection provider you will use to connect to the blockchain.
1. Your `.env` file should now look like the image after these instructions.
1. Run command `npm run deploy` which executes a script `scripts/deploy.ts` for deployment and Etherscan verification.
1. It takes a bit more than a minute to deploy and verify, but once that's done the script should give you an address for the contract.

<img src="assets/env.png" alt="Contents of .env file"></img>

<i>Example of .env file contents</i>

## Using the contract: user interfaces and integrations

Once a contract is deployed to some real blockchain (even testnet) there are two ways it can be utilized: through user interfaces or for other contracts to integrate with our contract.

For other contracts to connect to your contract, they need to have your contract's address and knowledge of the functionalities it supports. Contract address you get during deployment. To connect one contract to another, special contract types called *interfaces* are used. An interface simply lists contract functionality.

Typically, a contract has some sort of user interface built on top of it. This is often a website. The website utilizes [specialized libraries](https://docs.ethers.org) to interact with the blockchain through some *node provider* which provides access to the blockchain. The libraries makes it (relatively) easy for frontend developers to query contracts and to issue transactions to contracts.

### Etherscan user interface

The Etherscan service generates a crude user interface for verified contracts. It's useful for performing some manual tests on a deployed contract and to read its state.

